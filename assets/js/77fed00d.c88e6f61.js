"use strict";(self.webpackChunkgreenfield_docs=self.webpackChunkgreenfield_docs||[]).push([[6771],{63796:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const i={title:"Downloader",order:9},o="Downloader",s={unversionedId:"guide/storage-provider/services/downloader",id:"guide/storage-provider/services/downloader",title:"Downloader",description:"Downloader is responsible for downloading object data (including range download) and some query services",source:"@site/docs/guide/storage-provider/services/downloader.md",sourceDirName:"guide/storage-provider/services",slug:"/guide/storage-provider/services/downloader",permalink:"/opbnb-docs/docs/guide/storage-provider/services/downloader",draft:!1,editUrl:"https://github.com/bnb-chain/opbnb-docs/docs/guide/storage-provider/services/downloader.md",tags:[],version:"current",frontMatter:{title:"Downloader",order:9}},d={},c=[{value:"Overview",id:"overview",level:2},{value:"Quota Checker",id:"quota-checker",level:3},{value:"Piece Splitter",id:"piece-splitter",level:3},{value:"PieceStore Lib",id:"piecestore-lib",level:3},{value:"Quota Queryer",id:"quota-queryer",level:3},{value:"SP DB Lib",id:"sp-db-lib",level:3},{value:"GetObject Workflow",id:"getobject-workflow",level:2},{value:"Protocol",id:"protocol",level:2},{value:"RPC Interface",id:"rpc-interface",level:3},{value:"SP DB Interface",id:"sp-db-interface",level:3}],u={toc:c};function l(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"downloader"},"Downloader"),(0,a.kt)("p",null,"Downloader is responsible for downloading object data (including range download) and some query services\ninside SP, such as querying bills and detailed information."),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,(0,a.kt)("img",{src:r(53954).Z,width:"932",height:"578"})),(0,a.kt)("div",{style:{textAlign:"center"}},">",(0,a.kt)("i",null,"Downloader Architecture")),(0,a.kt)("h3",{id:"quota-checker"},"Quota Checker"),(0,a.kt)("p",null,"Check the quota configuration of the Bucket, if it exceeds, return out of quota. If not,\nadd a corresponding access record in the DB."),(0,a.kt)("h3",{id:"piece-splitter"},"Piece Splitter"),(0,a.kt)("p",null,"According to the configured piece segment size, the access to Object is internally divided into access to Piece."),(0,a.kt)("h3",{id:"piecestore-lib"},"PieceStore Lib"),(0,a.kt)("p",null,"Access the underlying piece storage, which may be different types of storage, such as local files,\nremote object storage, etc."),(0,a.kt)("h3",{id:"quota-queryer"},"Quota Queryer"),(0,a.kt)("p",null,"Provide Bucket Quota query interface and bill detail interface, and may provide more query interfaces in the future."),(0,a.kt)("h3",{id:"sp-db-lib"},"SP DB Lib"),(0,a.kt)("p",null,"Lib for accessing the underlying SP DB currently supports MySQL and may adapt to more underlying indexing services in the future."),(0,a.kt)("h2",{id:"getobject-workflow"},"GetObject Workflow"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Receives the GetObject request from the Gateway service."),(0,a.kt)("li",{parentName:"ul"},"Check whether the read traffic exceeds the quota.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If exceeds the quota, the Downloader refuses to serve and returns a not-enough-quota error to the Gateway."),(0,a.kt)("li",{parentName:"ul"},"If the quota is sufficient, the Downloader inserts read record into the SP traffic-db."))),(0,a.kt)("li",{parentName:"ul"},"Splits the GetObject request info the GetPiece requests(support range read) to get piece payload data,\nand returns the object payload data streaming to the Gateway.")),(0,a.kt)("h2",{id:"protocol"},"Protocol"),(0,a.kt)("h3",{id:"rpc-interface"},"RPC Interface"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"GetObject")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},"// GetObjectRequest is request type for the GetObject RPC method.\nmessage GetObjectRequest {\n  // bucket_info defines the information of the bucket.\n  bnbchain.greenfield.storage.BucketInfo bucket_info = 1;\n  // object_info defines the information of the object.\n  bnbchain.greenfield.storage.ObjectInfo object_info = 2;\n  // user_address defines the request user address.\n  string user_address = 3;\n  // is_range indicate whether it is ranged get, compatible aws s3\n  bool is_range = 4;\n  // range_start defines the start of range, [range_start, range_end],\n  // it is valid iff is_range is true.\n  uint64 range_start = 5;\n  // range_end defines the end of range, [range_start, range_end],\n  // it is valid iff is_range is true.\n  uint64 range_end = 6;\n}\n// GetObjectResponse is response type for the GetObject RPC method.\nmessage GetObjectResponse {\n  // data defines the download data\n  bytes data = 1;\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"GetBucketReadQuota")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},"// GetBucketReadQuotaRequest is request type for the GetBucketReadQuota RPC method.\nmessage GetBucketReadQuotaRequest {\n  // bucket info from the greenfield chain\n  bnbchain.greenfield.storage.BucketInfo bucket_info = 1;\n  // year_month is the query bucket quota's month, like \"2023-03\"\n  string year_month = 2;\n}\n\n// GetBucketReadQuotaResponse is response type for the GetBucketReadQuota RPC method.\nmessage GetBucketReadQuotaResponse {\n  // charged_quota_size is the greenfield chain bucket info's read quota size\n  uint64 charged_quota_size = 1;\n  // sp_free_quota_size is the sp default free quota\n  uint64 sp_free_quota_size = 2;\n  // consumed_size is currently consumed size\n  uint64 consumed_size = 3;\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ListBucketReadRecord")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},"// ListBucketReadRecordRequest is request type for the ListBucketReadRecord RPC method.\nmessage ListBucketReadRecordRequest {\n  // bucket info from the greenfield chain\n  bnbchain.greenfield.storage.BucketInfo bucket_info = 1;\n  // start_timestamp_us is the list request's left side, like [start_timestamp_us, end_timestamp_us)\n  int64 start_timestamp_us = 2;\n  // start_timestamp_us is the list request's right side, like [start_timestamp_us, end_timestamp_us)\n  int64 end_timestamp_us = 3;\n  // max_record_num is used to limit max list records\n  int64 max_record_num =4;\n}\n\n// ReadRecord is used to record the read request.\nmessage ReadRecord {\n  // object_name is the read object name\n  string object_name = 1;\n  // object_id is the read object id\n  uint64 object_id = 2;\n  // account_address is the read account address\n  string account_address = 3;\n  // timestamp_us is the read time stamp\n  int64 timestamp_us = 4;\n  // read_size is the read object size\n  uint64 read_size = 5;\n}\n\n// ListBucketReadRecordResponse is response type for the ListBucketReadRecord RPC method.\nmessage ListBucketReadRecordResponse {\n  // read_records are the read record list\n  repeated ReadRecord read_records = 1[(gogoproto.nullable) = true];\n  // next_start_timestamp_us is used to fetch next batch, When the list is completed, it is 0.\n  int64 next_start_timestamp_us = 2;\n}\n")),(0,a.kt)("h3",{id:"sp-db-interface"},"SP DB Interface"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},"// Traffic define a series of traffic interfaces\ntype Traffic interface {\n    // CheckQuotaAndAddReadRecord create bucket traffic firstly if bucket is not existed,\n    // and check whether the added traffic record exceeds the quota, if it exceeds the quota,\n    // it will return error, Otherwise, add a record and return nil.\n    CheckQuotaAndAddReadRecord(record *ReadRecord, quota *BucketQuota) error\n    // GetBucketTraffic return bucket traffic info,\n    // notice maybe return (nil, nil) while there is no bucket traffic\n    GetBucketTraffic(bucketID uint64, yearMonth string) (*BucketTraffic, error)\n    // GetBucketReadRecord return bucket record list by time range\n    GetBucketReadRecord(bucketID uint64, timeRange *TrafficTimeRange) ([]*ReadRecord, error)\n}\n")))}l.isMDXComponent=!0},53954:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/06-SP-Downloader-d7a9360880c139dcdb3fd1d5fec76f1e.jpg"}}]);